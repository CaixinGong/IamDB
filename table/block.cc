// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file. See the AUTHORS file for names of contributors.
//
// Decodes the blocks generated by block_builder.cc. 注意这句注释

#include "table/block.h"

#include <vector>
#include <algorithm>
#include "branchdb/comparator.h"
#include "table/format.h"
#include "util/coding.h"
#include "util/logging.h"

namespace branchdb {

inline uint32_t Block::NumRestarts() const {
  assert(size_ >= sizeof(uint32_t));
  return DecodeFixed32(data_ + size_ - sizeof(uint32_t));
}

//初始化4个成员变量
Block::Block(const BlockContents& contents)
    : data_(contents.data.data()),
      size_(contents.data.size()),
      owned_(contents.heap_allocated) {
  if (size_ < sizeof(uint32_t)) { //格式不对，至少包含num_restarts
    size_ = 0;  // Error marker
  } else {	
    size_t max_restarts_allowed = (size_-sizeof(uint32_t)) / sizeof(uint32_t);
    if (NumRestarts() > max_restarts_allowed) { //格式不对
      // The size is too small for NumRestarts()
      size_ = 0;
    } else {
      restart_offset_ = size_ - (1 + NumRestarts()) * sizeof(uint32_t);
    }
  }
}

Block::~Block() {
  if (owned_) {
    delete[] data_;
  }
}

// Helper routine: decode(解码) the next /block entry/ starting at "p",
// storing the number of shared key bytes, non_shared key bytes,
// and the length of the value in "*shared", "*non_shared", and
// "*value_length", respectively.  Will not derefence(解引用即*limit) past "limit".
//
// If any errors are detected, returns NULL.  Otherwise, returns a
// pointer to the key delta (just past the three decoded values).
// 返回值指向key delta
//只解析p(指向一个记录的起始)和limit(不包含）之间的第一个record，设置*shared, *non_shared, *value_length参数，
//若解析成功，将该记录从delta key开始的地址返回，否则返回NULL
static inline const char* DecodeEntry(const char* p, const char* limit, //调用时limit值为data_ + restart_
                                      uint32_t* shared,
                                      uint32_t* non_shared,
                                      uint32_t* value_length) {
  if (limit - p < 3) return NULL;
  *shared = reinterpret_cast<const unsigned char*>(p)[0]; // []的操作符优先级高于强制类型转换：单字节的0填充至4字节或8字节再转换为4字节
  *non_shared = reinterpret_cast<const unsigned char*>(p)[1];
  *value_length = reinterpret_cast<const unsigned char*>(p)[2];
  if ((*shared | *non_shared | *value_length) < 128) {//第7位（从0开始计数）为1，此条件即这三个值没有一个的第7位为1,即都为一位的varint32
    // Fast path: all three values are encoded in one byte each
    p += 3;
  } else {
    if ((p = GetVarint32Ptr(p, limit, shared)) == NULL) return NULL;  //p在调用完函数后已经移动
    if ((p = GetVarint32Ptr(p, limit, non_shared)) == NULL) return NULL;
    if ((p = GetVarint32Ptr(p, limit, value_length)) == NULL) return NULL;
  }

  if (static_cast<uint32_t>(limit - p) < (*non_shared + *value_length)) { //由此可见limit应该大于等于一条记录的(key+value)的末尾
    return NULL;
  }
  return p; //指向当条记录的key delta
}

//Iter为Block的私有类成员，Iterator 为抽象基类
class Block::Iter : public Iterator {
 private:
  const Comparator* const comparator_;
  const char* const data_;      // underlying block contents
  uint32_t const restarts_;     // Offset of restart array (list of fixed32)
  uint32_t const num_restarts_; // Number of uint32_t entries in restart array

  //下面几个私有成员都和当前处理的block entry的有关
  // current_ is offset in data_ of current entry.  >= restarts_ if !Valid
  uint32_t current_;
  uint32_t restart_index_;  // Index of restart block in which current_ falls
  std::string key_;
  Slice value_;//Slice,其.data还是指向"data_指向的空间的某一部分"中的
  Status status_;

  inline int Compare(const Slice& a, const Slice& b) const {
    return comparator_->Compare(a, b);
  }

  // Return the offset in data_ just past the end of the current entry.
  inline uint32_t NextEntryOffset() const {
    return (value_.data() + value_.size()) - data_;
  }

  //将restarts[index]的存储的值（小端）转成unit32_t,
  //返回的是第index（从0开始计数）个restart存储的 block entry的偏移量
  uint32_t GetRestartPoint(uint32_t index) {
    assert(index < num_restarts_);
    return DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));
  }

  //清空key_, 设置restart_index为index, value_设置为长度为0，但其偏移量为整条记录的起始偏移量
  void SeekToRestartPoint(uint32_t index) {
    key_.clear();
    restart_index_ = index;
    // current_ will be fixed by ParseNextKey(); 注意这条注释

    // ParseNextKey() starts at the end of value_, so set value_ accordingly
    // 即将value_设置为长度为0，但其偏移量为整条记录的起始偏移量
    uint32_t offset = GetRestartPoint(index);
    value_ = Slice(data_ + offset, 0);
  }

 public:
  //value_, key_, status_都调用了默认构造函数
  Iter(const Comparator* comparator,
       const char* data,
       uint32_t restarts,
       uint32_t num_restarts)
      : comparator_(comparator),
        data_(data),
        restarts_(restarts), //restart数组的起始偏移量
        num_restarts_(num_restarts),
        current_(restarts_),            //停留在末尾(当前为无效值)
        restart_index_(num_restarts_) { // 停留在末尾(当前为无效值)，Index of restart block in which current_ falls
    assert(num_restarts_ > 0);
  }

  virtual bool Valid() const { return current_ < restarts_; } //只调用了构造函数,当前为无效值
  virtual Status status() const { return status_; } //默认为success(即没有发生错误)
  //当前需为有效值
  virtual Slice key() const {
    assert(Valid());
    return key_;
  }
  //当前需为有效值
  virtual Slice value() const {
    assert(Valid());
    return value_;
  }

  //当前需为有效值
  virtual void Next() {
    assert(Valid());
    ParseNextKey();//若value_ + value_.size()后面有记录且正确；将改变 current_ key_ value_  可能改变 restart_index_，并返回true
  }

  //当前需为有效值, 若前面无记录，设置为无效状态
  virtual void Prev() {
    assert(Valid());

    // Scan backwards to a restart point before current_
    const uint32_t original = current_;
    while (GetRestartPoint(restart_index_) >= original) {//当当前记录的上一条在另一个restart point的范围取==,退出循环后后会进入另一个restart的范围中
      if (restart_index_ == 0) { //说明prev已经没有记录了,故设置为无效状态
        // No more entries
        current_ = restarts_; //停留在末尾(当前为无效值)
        restart_index_ = num_restarts_; //停留在末尾(当前为无效值)
        return;
      }
      restart_index_--;
    }

    SeekToRestartPoint(restart_index_); //清空key_, 设置restart_index, value_设置为长度为0，但其偏移量为整条记录的起始偏移量
    do {
      // Loop until end of current entry hits the start of original entry
    } while (ParseNextKey() && NextEntryOffset() < original); //当==时退出循环,即下一条记录的偏移等于==orginal，所以当前记录是original的prev
  }
  //先用二分法搜索到最后一个 "restart point对应的记录小于target" 的restart point，
  //然后从该点开始搜索到第一个key>=taget的记录
  virtual void Seek(const Slice& target) {
    // Binary search in restart array to find the last restart point
    // with a key < target
    uint32_t left = 0;
    uint32_t right = num_restarts_ - 1;

    //此二分查找对普通二分查找进行了改编,寻找最后一个restart point对应的记录小于（不等于）target的点
    while (left < right) { //一定有结果，故==即可退出
      uint32_t mid = (left + right + 1) / 2; //若left 和 right相差1，则mid取较大的那个，若取较小那个(即不用+1)，应该也行，因为right都会右移
      uint32_t region_offset = GetRestartPoint(mid);
      uint32_t shared, non_shared, value_length;
      const char* key_ptr = DecodeEntry(data_ + region_offset, //当前的必为start point，所以shared == 0
                                        data_ + restarts_,
                                        &shared, &non_shared, &value_length);
      if (key_ptr == NULL || (shared != 0)) {
        CorruptionError();//将当前状态设置为无效状态，并设置status_，clear掉key_和value_
        return;
      }
      Slice mid_key(key_ptr, non_shared); //因为shared的长度为0
      if (Compare(mid_key, target) < 0) {// mid 可能就是最终结果所以不能left = mid - 1
        // Key at "mid" is smaller than "target".  Therefore all
        // blocks before "mid" are uninteresting.
        left = mid;
      } else {//==是不符合的，所以mid一定不符合，所以 right = mid - 1
        // Key at "mid" is >= "target".  Therefore all blocks at or
        // after "mid" are uninteresting.
        right = mid - 1;
      }
    }

    // Linear search (within restart block) for first key >= target
    SeekToRestartPoint(left);//清空key_, 设置restart_index, value_设置为长度为0，但其偏移量为整条记录的起始偏移量
    while (true) {
	  //若current_后面有记录且正确；将改变current_ key_ value_  “可能改变 restart_index_”，并返回true
	  //若current_后面没有记录：则返回false，并设置为无效状态（设置current_和restart_index_），并返回false
	  //若current_后面下一个的record格式错误：设置为无效状态（设置current_和restart_index_）,并设置status_，clear掉key_和value_，并返回false
      if (!ParseNextKey()) {
        return;
      }
      if (Compare(key_, target) >= 0) {
        return;
      }
    }
  }

  virtual void SeekToFirst() {
    SeekToRestartPoint(0);//清空key_, 设置restart_index, value_设置为长度为0，但其偏移量为整条记录的起始偏移量
    ParseNextKey();   //若value_ + value_.size()后面有记录且正确；将改变 current_ key_ value_  可能改变 restart_index_，并返回true
  }

  virtual void SeekToLast() {
    SeekToRestartPoint(num_restarts_ - 1);//清空key_, 设置restart_index, value_设置为长度为0，但其偏移量为整条记录的起始偏移量
    while (ParseNextKey() && NextEntryOffset() < restarts_) {//解析最后一个restart point的所有记录，并parse最后一条(读取其值到key_ value_)
      // Keep skipping
    }
  }

 private:
  //因为格式错误(可能坏块)，将当前状态设置为无效状态，并设置status_，clear掉key_和value_
  void CorruptionError() {
    current_ = restarts_;//停留在末尾(当前为无效值)
    restart_index_ = num_restarts_;//停留在末尾(当前为无效值)
    status_ = Status::Corruption("bad entry in block");
    key_.clear();
    value_.clear();
  }

//若value_ + value_.size()后面有记录且正确；将改变 current_ key_ value_  可能改变 restart_index_，并返回true
//若value_ + value_.size()后面没有记录：则返回false，并设置为无效状态（设置current_和restart_index_），并返回false
//若value_ + value_.size()后面下一个的record格式错误：设置为无效状态（设置current_和restart_index_）,并设置status_，clear掉key_和value_，并返回false
  bool ParseNextKey() {
    current_ = NextEntryOffset(); //返回value_ + value_.size()后面位置的偏移量
    const char* p = data_ + current_;
    const char* limit = data_ + restarts_;  // Restarts come right after data
    if (p >= limit) {  //后面没有记录
      // No more entries to return.  Mark as invalid.
      current_ = restarts_;//停留在末尾(当前为无效值)
      restart_index_ = num_restarts_;//停留在末尾(当前为无效值)
      return false;
    }

    // Decode next entry
    uint32_t shared, non_shared, value_length;

	//解析p只limit之间的第一个record，设置*shared, *non_shared, *value_length参数，
	//若解析成功，将该记录从delta key开始的地址返回，否则返回NULL
    p = DecodeEntry(p, limit, &shared, &non_shared, &value_length);
    if (p == NULL || key_.size() < shared) { //格式错误(seekToFirst和seekToLast调用前都要将key_进行clear，或者当前key_为上一条的key,故此条件应满足)
      CorruptionError(); //将当前状态设置为无效状态，并设置status_，clear掉key_和value_
      return false;
    } else {
      key_.resize(shared);//给key_赋值完整的key
      key_.append(p, non_shared);
      value_ = Slice(p + non_shared, value_length);//给value_赋值
      while (restart_index_ + 1 < num_restarts_ &&  //当读取这条记录后跳过了当前restart_index_的范围则需将restart_index_++
             GetRestartPoint(restart_index_ + 1) < current_) {
        ++restart_index_;
      }
      return true;
    }
  }
};

//返回的是一个抽象基类的指针（实际指向Block的一个私有类成员或iterator.cc中定义的一个EmptyIterator ）实现多态
Iterator* Block::NewIterator(const Comparator* cmp) {
  if (size_ < sizeof(uint32_t)) {//一个block至少得有num_restarts
    return NewErrorIterator(Status::Corruption("bad block contents"));
  }
  const uint32_t num_restarts = NumRestarts();
  if (num_restarts == 0) {
    return NewEmptyIterator();
  } else {
    return new Iter(cmp, data_, restart_offset_, num_restarts);//使用了三个成员变量
  }
}

}  // namespace branchdb
